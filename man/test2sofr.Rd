% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test2sofr.R
\name{test2sofr}
\alias{test2sofr}
\title{Bootstrap tests for two-sample functional linear regression}
\usage{
test2sofr(
  Y,
  X,
  tGrid,
  group,
  h_max = 20,
  rho_vec = c(seq(0.75, 0.95, by = 0.05), 0.99, 0.995, 0.999),
  B = 1000,
  ap = 0.05
)
}
\arguments{
\item{Y}{A vector of n responses from two gruops.}

\item{X}{An n by p matrix of regressor curves from two groups. Each row represents one observed regressor curve.}

\item{tGrid}{A vector of p densely equi-spaced time grid points where the curve are evaluated.}

\item{group}{A vector of n elements that indicates two groups.}

\item{h_max}{A positive integer value that represents the maximum of candidate truncation levels.}

\item{rho_vec}{A vector of the threshold values using to choose the truncation levels; these must be numeric values between 0 and 1.}

\item{B}{A positive integer. The number of bootstrap resamples with default 1000.}
}
\value{
A list containing the following fields:
\item{res_hEach}{The test statistics, the corresponding p-values, and the values of variance explained for each truncation level from 1 to h_max} 
\item{res_hSel}{The test statistics, the corresponding p-values, and the selected truncation levels by using different types of variance explained with threshold values in rho_vec}
}
\description{
Conduct bootstrap tests by Yeon and Kokoszka (2025) for assessing the equality of the slope functions in two scalar-on-function linear regression models.
The test statistics are built based on either eigendecomposition of the pooled covariance operator (PD) or simultaneously diagonalized components (SD) from group-specific covariance operators.
Residual-type bootstrap methods are employed to improve accuracy either imposing the null or not.
The truncation levels are chosen by using fraction of variance explained (FVE) or relative variance explained (RVE).
}
\examples{

# example

library(BTSinFLRM)

Jtrue=20 # The number of basis elements used in data generation

# create eigenvalues based on polynomial eigengaps with rate a
ev_poly = function(a, c, J){
  dt = c*(1:J)^(-a)
  ld1 = c*VGAM::zeta(a)
  ld = c(ld1, sapply(1:(J-1), function(j){ld1 - sum(dt[1:j])}))
  return(ld)
}

# eigenvalues for unequal cov
ga_rough  = ev_poly(2.5, 2, Jtrue) # a=2.5
ga_smooth = ev_poly(5, 2, Jtrue)   # a=5

# Equi-spaced time grid points in [0,1]
tt = 50; tGrid_ttt = seq(0, 1, len=tt+1); 
tGrid = tGrid_ttt[1:tt]
diffrange = diff(tGrid)[1] + diff(range(tGrid)) # when using left points
scal = diffrange / tt   # scaling factor for integration

# basis functions for beta, and for X under equal cov
phi_base = t(fda::fourier(tGrid_ttt, 2*Jtrue))[-1,1:tt]  # trigonometric functions
phi = phi_base[1:Jtrue,]

# basis functions for X under unequal cov
mono = t(sapply(1:Jtrue, function(j)tGrid^j))
phi_mono = BTSinFLRM:::orthoL2Equidense(mono, tGrid)
cheb = t(sapply(1:Jtrue, function(j)pracma::chebPoly(j, 2*tGrid-1)))
phi_cheb = BTSinFLRM:::orthoL2Equidense(cheb, tGrid)

# Slope functions
b=2; Wbetaj = rbinom(Jtrue, 1, 0.5)*2-1
bj = 3*((1:Jtrue)^(-b))*Wbetaj; beta = c(bj \%*\% phi)

beta_arr = array(0, dim=c(2, tt, 2), dimnames=list(
  1:2, NULL, paste0("type", 0:1)
))
# 0: linear difference
beta_arr[1,,"type0"] = 1*beta
beta_arr[2,,"type0"] = 2*beta

# 1: orthogonal difference
beta_arr[1,,"type1"] = c(bj[1:5] \%*\% phi[1:5,])
beta_arr[2,,"type1"] = c(bj[1:5] \%*\% phi[6:10,])

beta1 = beta_arr[1,,"type0"]
c_alter = 0.5 # strength of alternative
beta2 = (1-c_alter)*beta1 + c_alter*beta_arr[2,,"type0"]

# Determine the second order structures
eveq = TRUE # eigenvalues are equal?
efeq = TRUE # eigenfunctions are equal?
if(eveq){  # equal eigenvalues
  ga1 = ga2 = ga_rough
}else{  # unequal eigenvalues
  ga1 = ga_smooth; ga2 = ga_rough
}
if(efeq){  # equal eigenfunctions
  phi1 = phi; phi2 = phi
}else{  # unequal eigenfunctions
  phi1 = phi_mono; phi2 = phi_cheb
}

# Other factors

n=50; n1 = n2 = n/2      # n1=48; n2=52
group = c(rep(1,n1), rep(0,n2))
idx1 = as.logical(group); idx2 = !idx1
xi_type=0 # Gaussian random function
er_type=0 # Normal error
sig_sq =1 # the error variance

# # # # # # # # # # # 
# generate data

# FPC scores
Wj = matrix(rnorm(n*Jtrue), n, Jtrue)
if(xi_type==2){
  xi = rexp(n) - 1 # normal*exp FPC scores
}else if(xi_type==1){
  xi = rnorm(n) # normal*normal FPC scores
}else{
  xi = rep(1,n) # independent FPC scores
}

# # unequal FPC scores
# xi1 = rnorm(n1); xi2 = rexp(n2) - 1
# xi[idx1,] = xi1; xi[idx2,] = xi2

Xfpc = matrix(0, n, Jtrue)
Xfpc[idx1,] = t(sqrt(ga1) * t(xi[idx1]*Wj[idx1,]))
Xfpc[idx2,] = t(sqrt(ga2) * t(xi[idx2]*Wj[idx2,]))

# regerssor functions

X = matrix(0, n, tt)
X[idx1,] = Xfpc[idx1,] \%*\% phi1
X[idx2,] = Xfpc[idx2,] \%*\% phi2

X1 = X[idx1,]; X2 = X[idx2,]

X1beta1 = c(X1 \%*\% beta1 * scal)
X2beta2 = c(X2 \%*\% beta2 * scal)

if(er_type==1){   # centered exponential error
  par_scale = sqrt(sig_sq)
  er = rexp(n, 1/par_scale) - par_scale
}else{     # normal error
  er = rnorm(n, 0,sd=sqrt(sig_sq))          
}

# response variables
Y1 = X1beta1 + er[idx1]
Y2 = X2beta2 + er[idx2]
Y = rep(0,n); Y[idx1] = Y1; Y[idx2] = Y2

# Bootstrap tests for two-sample scalar-on-function regression (not run)
# res = test2sofr(Y, X, tGrid, group)

}
\references{
Yeon, H. and Kokoszka, P. (2025). Bootstrap two-sample tests for scalar-on-function regression. \emph{Submitted}
}
